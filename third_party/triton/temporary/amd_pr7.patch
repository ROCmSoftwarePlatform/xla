==== triton/BUILD#46 - /google/src/cloud/csigg/triton_amd/triton/BUILD ====
# action=edit type=text
--- triton/BUILD	2024-04-11 02:00:21.000000000 -0700
+++ triton/BUILD	2024-04-21 23:52:01.000000000 -0700
@@ -725,12 +725,12 @@
         "@llvm-project//llvm:Support",
         "@llvm-project//mlir:ControlFlowDialect",
         "@llvm-project//mlir:GPUDialect",
+        "@llvm-project//mlir:GPUToROCDLTransforms",
         "@llvm-project//mlir:IR",
-        "@llvm-project//mlir:LLVMCommonConversion",
         "@llvm-project//mlir:LLVMDialect",
         "@llvm-project//mlir:NVVMDialect",
         "@llvm-project//mlir:Pass",
-        "@llvm-project//mlir:TransformUtils",
+        "@llvm-project//mlir:ROCDLDialect",
         "@llvm-project//mlir:Transforms",
     ],
 )
==== triton/third_party/amd/BUILD#None - /google/src/cloud/csigg/triton_amd/triton/third_party/amd/BUILD ====
# action=add type=text
diff --git a/third_party/amd/BUILD b/third_party/amd/BUILD
new file mode 100644
index 0000000..ee4bc37
--- /dev/null
+++ b/third_party/amd/BUILD
@@ -0,0 +1,128 @@
+load("@llvm-project//mlir:tblgen.bzl", "gentbl_cc_library", "td_library")
+
+
+package(
+    # copybara:uncomment_begin
+    # default_applicable_licenses = ["//:license"],
+    # default_visibility = [
+        # "//third_party/tensorflow/compiler/xla/service/gpu:__subpackages__",
+        # "//:__subpackages__",
+    # ],
+    # copybara:uncomment_end_and_comment_begin
+    default_visibility = ["//visibility:public"],
+    # copybara:comment_end
+)
+
+# TODO(csigg): fix, enable error upstream, remove.
+_no_unused_variable = select({
+    "//:compiler_is_msvc": [],
+    "//conditions:default": ["-Wno-unused-variable"],
+})
+
+cc_library(
+    name = "TritonAMDGPUTransforms",
+    srcs = glob([
+        "lib/TritonAMDGPUTransforms/*.h",
+        "lib/TritonAMDGPUTransforms/*.cpp",
+    ]),
+    hdrs = glob([
+        "include/TritonAMDGPU/*.h",
+        "include/TritonAMDGPUTransforms/*.h",
+        "lib/TritonAMDGPUTransforms/*.h",
+    ]),
+    copts = _no_unused_variable,
+    includes = [
+        "..",
+        "include",
+        "lib/TritonAMDGPUTransforms",
+    ],
+    deps = [
+        ":triton_conversion_amdgpu_to_llvm_passes_inc_gen",
+        "@llvm-project//mlir:ConvertToLLVM",
+        "@llvm-project//mlir:IR",
+        "@llvm-project//mlir:LLVMCommonConversion",
+        "@llvm-project//mlir:LLVMDialect",
+        "@llvm-project//mlir:Pass",
+        "@llvm-project//mlir:Support",
+        "@llvm-project//mlir:TransformUtils",
+        "@llvm-project//mlir:Transforms",
+        "//:TritonAnalysis",
+        "//:TritonDialects",
+        "//:TritonGPUToLLVM",
+        "//:TritonGPUTransforms",
+    ],
+)
+
+cc_library(
+    name = "TritonAMDGPUToLLVM",
+    srcs = glob([
+        "lib/TritonAMDGPUToLLVM/**/*.h",
+        "lib/TritonAMDGPUToLLVM/**/*.cpp",
+    ]),
+    hdrs = glob([
+        "include/TritonAMDGPUToLLVM/**/*.h",
+    ]) + [
+        "lib/TritonAMDGPUToLLVM/Utility.h",
+    ],
+    copts = _no_unused_variable,
+    includes = [
+        "..",
+        "include",
+        "lib/TritonAMDGPUToLLVM",
+    ],
+    deps = [
+        ":triton_transforms_amdgpu_to_llvm_passes_inc_gen",
+        "@llvm-project//mlir:ConvertToLLVM",
+        "@llvm-project//mlir:IR",
+        "@llvm-project//mlir:LLVMCommonConversion",
+        "@llvm-project//mlir:LLVMDialect",
+        "@llvm-project//mlir:Pass",
+        "@llvm-project//mlir:Support",
+        "@llvm-project//mlir:TransformUtils",
+        "@llvm-project//mlir:Transforms",
+        "//:TritonAnalysis",
+        "//:TritonDialects",
+        "//:TritonGPUToLLVM",
+        ":TritonAMDGPUTransforms",
+    ],
+)
+
+td_library(
+    name = "td_files",
+    srcs = glob(["include/**/*.td"]),
+    includes = ["include"],
+    deps = ["//:td_files"],
+)
+
+gentbl_cc_library(
+    name = "triton_transforms_amdgpu_to_llvm_passes_inc_gen",
+    tbl_outs = [
+        (
+            [
+                "--gen-pass-decls",
+                "--name=TritonAMDGPUToLLVM",
+            ],
+            "include/TritonAMDGPUToLLVM/Passes.h.inc",
+        ),
+    ],
+    tblgen = "@llvm-project//mlir:mlir-tblgen",
+    td_file = "include/TritonAMDGPUToLLVM/Passes.td",
+    deps = [":td_files"],
+)
+
+
+gentbl_cc_library(
+    name = "triton_conversion_amdgpu_to_llvm_passes_inc_gen",
+    tbl_outs = [
+        (
+            [
+                "--gen-pass-decls",
+                "--name=TritonAMDGPU",
+            ],
+            "include/TritonAMDGPUTransforms/Passes.h.inc",
+        ),
+    ],
+    tblgen = "@llvm-project//mlir:mlir-tblgen",
+    td_file = "include/TritonAMDGPUTransforms/Passes.td",
+    deps = [":td_files"],
+)
diff --git a/third_party/amd/lib/TritonAMDGPUToLLVM/ElementwiseOpToLLVM.cpp b/third_party/amd/lib/TritonAMDGPUToLLVM/ElementwiseOpToLLVM.cpp
index f59efd6..cf601f0 100644
--- a/third_party/amd/lib/TritonAMDGPUToLLVM/ElementwiseOpToLLVM.cpp
+++ b/third_party/amd/lib/TritonAMDGPUToLLVM/ElementwiseOpToLLVM.cpp
@@ -1132,6 +1132,21 @@ struct FpToFpOpConversion
     for (unsigned i = 0; i < std::min(numElements, operands.size()); i++) {
       inVals.push_back(operands[i][0]);
     }
+
+    bool isSrcFP16 = srcElementType.isF16();
+    bool isSrcBF16 = srcElementType.isBF16();
+
+    if ((isSrcFP16 || isSrcBF16)
+          && isDstFP32) {
+      SmallVector<Value> outVals;
+      for (Value &v : inVals) {
+        if(isSrcFP16)
+          outVals.push_back(convertFp16ToFp32(loc, rewriter, v));
+        else
+          outVals.push_back(convertBf16ToFp32(loc, rewriter, v));
+      }
+      return outVals;
+    }
     if (useFP16IntermediateSrc)
       for (Value &v : inVals)
         v = convertFp32ToFp16NZ(loc, rewriter, v);
diff --git a/third_party/amd/lib/TritonAMDGPUToLLVM/LoadStoreOpToLLVM.cpp b/third_party/amd/lib/TritonAMDGPUToLLVM/LoadStoreOpToLLVM.cpp
index 83f24d711..82aad06c5 100644
--- a/third_party/amd/lib/TritonAMDGPUToLLVM/LoadStoreOpToLLVM.cpp
+++ b/third_party/amd/lib/TritonAMDGPUToLLVM/LoadStoreOpToLLVM.cpp
@@ -599,12 +599,23 @@ struct AtomicRMWOpConversion
       auto maybeKind = matchAtomicOp(atomicRmwAttr);
       // TODO: use rocdl.raw.buffer.atomic from ROCDL dialect to use efficient
       // atomics for MI-* series of AMD GPU.
+      if(isa<FloatType>(valElements[i].getType()) &&
+         (*maybeKind != mlir::LLVM::AtomicBinOp::fadd)) {
+        valElem = bitcast(valElements[i],
+          int_ty(valElements[i].getType().getIntOrFloatBitWidth()));
+      }
+
       Value atom = rewriter
                        .create<LLVM::AtomicRMWOp>(
                            loc, *maybeKind, rmwPtr, valElements[i],
                            atomicMemOrdering, StringRef("agent"))
                        .getResult();

+      if(isa<FloatType>(valElements[i].getType()) &&
+         (*maybeKind != mlir::LLVM::AtomicBinOp::fadd)) {
+        atom = bitcast(atom, valElements[i].getType());
+      }
+
       // NV for the f16v2 case generates one packed instruction. We have to
       // create two separate instructions since LLVM::AtomicRMWOp doesn't
       // support this. Can be optimized out with rocdl.raw.buffer.atomic.
